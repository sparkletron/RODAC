\documentclass{article}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[hidelinks]{hyperref}
\begin{document}
  \begin{titlepage}
    \begin{center}

    {\Huge RODAC}

    \vspace{25mm}

    \includegraphics[width=0.90\textwidth,height=\textheight,keepaspectratio]{src/img/SPARKLETRON.png}

    \vspace{25mm}

    \today

    \vspace{15mm}

    {\Large Jay Convertino}

    \vspace{25mm}
    {\Huge PRE-ALPHA}

    \end{center}
  \end{titlepage}

  \tableofcontents

  \newpage

  \section{Usage}

  \subsection{Introduction}

  \par
  This manual describes how to use the RODAC (Retro Only Device Application Creation) system for development.
  Items such as how to build included apps, what the structure of the system looks like, and how to create your
  own app is included. The final section are links to doxygen generated documentation about the drivers used
  by this system.
  \par
  RODAC is a multisystem development kit that targets retro systems with a z80 CPU and TMS based video display
  processors. Various sound and other IO peripheral are supported. RODAC is made to be a easy to use by creating
  a modern directory structure and library system for the code. All code, outside of the C runtime is written
  in C. This makes porting between systems easier and the code readable. Applications can be made to target
  all or just a few of the systems architectures by including only the makefiles for the those systems. This is due to each
  architecture using the same file structure.
  \par
  Overall the system makes adding new architecture targets, applications, and drivers easy. Allowing other systems
  to be added quickly and effortlessly. Inline assembler is avoided so future iterations may support other CPU targets,
  though this is a distant goal. RODAC is a development kit for retro systems that makes development about the
  application, not the processes of trying to build it.

  \subsection{Dependencies}

  \par
  The following are the dependencies needed to build the applications targeting various retro systems.

  \begin{itemize}
    \item sdcc 4.X.X
    \item python 3.X
    \item make
  \end{itemize}

  \subsection{Building}

  \par
  Makefiles are used to execute all builds. All sources will rebuild when make because the libraries must be updated.
  If this didn't happen the new memory map setup in the defines.h would not be applied. Each application
  has its makefile located in its root folder. To run a build you must run, in the target apps root folder, the following
  command.

  \begin{lstlisting}[language=bash]
    $ make SYSTEM
  \end{lstlisting}

  Where SYSTEM is the target you would like to build for. All will do nothing but toss an error telling you the same.
  Currently the targets are \textbf{coleco, coleco\_sgm, msx, sg1000}. All targets have been tested for coleco based systems.
  The others are not tested on real hardware at the moment.

  \subsubsection{hello\_world}

  \par
  Hello World is a simple application that prints all of the characters from the TMS memory to screen. It also prints hello world in the
  center of the screen and scrolls it horizontally. This is done in the TMS txt mode with 40 columns and no sprites. This application has been
  tested in emulation on all available systems. It also generates a single annoying constant tone, as a really poor sound test. To build this
  run the following for the Colecovision in the root of the apps/hello\_world folder.

  \begin{lstlisting}[language=bash]
    $ make coleco
  \end{lstlisting}

  \subsubsection{multicart}

  \par
  Multicart creates a non-scrolling list of ROMs in alphabetical order. The number of ROMs is limited by the target flash size and the number of
  lines (21) on screen. The generation of the header that contains the list of ROMs is automatically updated with new rom using a python
  script, rom\_header\_gen.py. The full ROM is also auto generated by a python script rom\_file\_gen.py. Currently these default to the roms folder
  located in the apps/multicart folder root. This can be changed in the make file via the ROM\_\* variables. There are dummy ROMs with random data
  for testing of the system. This will work in an emulator up to the point of bank switching ROMs, since the PIC and the logic with it is not emulated.
  This is currently only targeted and tested on the Colecovision. To build for the Colecovision you would run the following in the apps/multicart folder.

  \begin{lstlisting}[language=bash]
    $ make coleco
  \end{lstlisting}

  \subsection{Directory Guide}

  \par
  Below highlights important folders from the root of RODAC.

  \begin{enumerate}
    \item \textbf{docs} Contains all documentation related to this project.
      \begin{itemize}
        \item \textbf{arch} Contains all architecture docs related to retro systems.
        \item \textbf{manual} Contains user manual and wiki that are generated from the same latex source.
      \end{itemize}
    \item \textbf{apps} Contains source code in C for the applications to run on the target architecture.
      \begin{itemize}
        \item \textbf{hello\_world} Example hello world application. Targets all architectures.
        \item \textbf{mutlicart} Example multicart application, written for the coleco only.
      \end{itemize}
    \item \textbf{drivers} Contains all source code related to the project.
      \begin{itemize}
        \item \textbf{gisnd} Simple driver for the GI AY-3-8910 sound chip and its variants.
        \item \textbf{sn76489} driver for the TI SN76489 sound chip.
        \item \textbf{tms99XX} driver for all TMS99XX and TMS9XXX video chips.
      \end{itemize}
  \end{enumerate}

  \newpage

  \section{Creating new apps, drivers, or systems.}

  \par
  My goal is to create an easy way to add new parts to this system. The best way to start is to copy and pasta something
  that is close and edit it. This applies to Applications, Architecture, and Drivers. The following subsections explain each
  part when it comes to the files and structure.

  \subsection{Application Creation}

  \paragraph{The structure}of the apps should be consistent. All apps are located in the apps folder.
  The base folder should be a recognizable name. For this examples we will call it example.
  The easy way to get started is the to copy and rename the hello\_world example.
  \begin{lstlisting}[language=bash]
    $ cp -r hello_world example
  \end{lstlisting}
  The above command will copy and rename the folder to example. This assumes hello\_world has not been built.
  This folder will contain a src directory, a makefile, and a readme. I recommend a readme so the user can quickly find out what
  the program does. You now have a starting point for creating your application.

  \paragraph{Makefile}kicks off the main build and contains the system targets available. All builds call sdcc as the compiler and use
  CFLAGS and LFLAGS to set various flags. These flags also include variables that are set by the system include makefiles. This makefile
  will call all other makefiles used for driver, and architecture builds.

    \begin{lstlisting}[language=make]
ifeq (coleco_sgm,$(MAKECMDGOALS))
include ../../arch/coleco_sgm.mk
LIBPATH += ../../drivers/gisnd
LIBPATH += ../../drivers/sn76489
BIN    := $(addprefix $(MAKECMDGOALS)_, $(BIN))
DIROBJ := $(addprefix $(MAKECMDGOALS)_, $(DIROBJ))
endif
  \end{lstlisting}

  The above is an example of add a architecure target. In this case if the make variable MAKECMDGOALS is equal to coleco\_sgm, the the makefile for it is included along with driver libraries.
  This will also prefix all the outputs for the application with the contents of MAKECMDGOALS. Alterations such as changing coleco\_sgm to your new architecture, or adding or removing drivers
  is done in this block.

  A few last notes, all source files will be added from the source directory (src). If you need to include headers, I recommend putting them in there own folder and adding a flag to the end of CFLAGS.
  The following is an example of using a variable to add a header directory.

  \begin{lstlisting}[language=make]
-I$(HEADER_DIR)
  \end{lstlisting}

  \paragraph{The source}is located in the src directory of the application folder, in this case named example. This can be any name you wish, but I recommend using the same name as the your application.
  There should be only one file, the main executable. Any utilities, drivers, and other items should be external and called in as libraries that are built by the makefile. This helps make core reusable
  and less congested. Things such as a game engine would be a separate folder in the root of the RODAC directory. Future examples will be added, though none are done at this moment in pre-alpha.

  \subsection{Architecture Creation}

  \paragraph{The structure}of the architecture of each system is consistent. All architectures are located in the arch folder in the root of RODAC.
  Each one has its own makefile.mk with the name SYSTEM.mk. Where SYSTEM is the target. For instance coleco.mk is for the colecovision. The base header (base.h)
  file is for all of the architecture targets and holds defines and functions that are used for all. In the architecture folder named after the target, Colecovision the name would be coleco,
  contain the header file defines.h and the source files. The defines.h contains the port locations and memory map locations that are used by drivers. The base.c file
  is the actual functions definitions of the declared functions in base.h. The makefile is a universal build for the target system library. To create a new architecture i
  t is recommended to copy an existing system and rename it.
  \begin{lstlisting}[language=bash]
$ cp -r coleco example
$ cp coleco.mk example.mk
  \end{lstlisting}
  The above commands will copy and rename the folder and all its contents to example, and copy the makefile to a new file named example.mk.

  \paragraph{Makefile.mk} are the various makefiles in the arch folder named for their architecture target. In this case we are looking at coleco.mk.
  In coleco.mk the system is setup by variables, they are shown below.

    \begin{lstlisting}[language=make]
SYS_DEFINE := _COLECO
ARCH  := z80

BASELIBPATH := ../../arch/
BASELIBARCH := coleco
BASELIBNAME := $(BASELIBPATH)$(BASELIBARCH)/base.lib

CODELOC   := 0x8100
DATALOC   := 0x7000
IRAMSIZE  := 1024
  \end{lstlisting}

  The above variables control the base system information, they are the following.

  \begin{itemize}
    \item \textbf{SYS\_DEFINE} A define used in various other C files to switch out code. Should only be used in applications sparingly.
    \item \textbf{ARCH} Defines the CPU target, currently only z80 is supported.
    \item \textbf{BASELIBPATH} Path to this arch folder, relative to the apps folder.
    \item \textbf{BASELIBARCH} Name for the architecture. This should be the system name and match the folder and makefile.mk name.
    \item \textbf{BASELIBNAME} Complete path and name for the base library file.
    \item \textbf{CODELOC} Start of the C code location. This is after the crt0.s.
    \item \textbf{DATALOC} Start of the RAM location of the system.
    \item \textbf{IRAMSIZE} Number of bytes of RAM the system has.
  \end{itemize}

  \paragraph{Base header} is simply a collection of functions and defines for all systems. It will also include the defines from the target architecture.
  When implementing your own base.c, these functions must be supplied. They are as follows.

  \begin{itemize}
    \item \textbf{\_\_delay\_us} A function that does a busy loop delay in microseconds. This has to be tuned to each system.
    \item \textbf{set\_vdp\_irq\_callback} A function that sets the VDP IRQ callback. This is usually connected to the NMI interrupt.
    \item \textbf{set\_spin\_irq\_callback} This is coleco specific. This function is for the interrupt generated by the spin controller. Needs to removed in the future.
    \item \textbf{getControllerOne} Base function for getting controller one 8 bit output. This is bare bones at the moments and defines.h contains the button bit defines.
    \item \textbf{getControllerTwo} Same as getControllerOne.
  \end{itemize}

  \paragraph{Defines header} contains all the defines for the system. At this moment this document will not list each one, but will talk about the general idea.
  The defines included contain button bit locations for the getController functions. Another set of defines, that end in  \_ADDR are all port addresses of the
  devices connected to the z80 processor. Variables ending in \_PORT are the z80 io port locations (0 to 255) of the devices to access. Then there are two defines
  called ei() (enable interrupt) and di() (disable interrupt). This was done to match the original xc8-cc PIC library calls that the driver libraries where ripped from.

  \paragraph{Source file base} is the source file that implements the base.h functions. It contains the function pointers that end up linking to crt0.s for IRQ calls.

  \paragraph{C runtime file} is the set of assembly instructions that setup the system in question and executes the main C function. This is written on a system by system basis.
  Differences such as SGM vs non-SGM Colecovision consoles are dealt with here. Where stack pointers should start, and how to initialize data regions.

  \subsection{Driver Creation}

  \paragraph{The structure}of the drivers is consistent across all drivers. They contain a header that is doxygen commented, makefile, and src directory containing the source file.
  A license can also be added if need be, along with additional sources such as headers and such. There are no files in the drivers folder, just folders that contains the driver folders
  with the files for the target driver. The output is follows the name of the folder in the drivers folder and is case sensitive. Easy way of starting creation of your own driver
  is to copy one close to what you're targeting. In this case I will add a new sound chip, example.

  \begin{lstlisting}[language=bash]
$ cp -r gisnd example
  \end{lstlisting}

  The above commands will copy and rename the folder and all its contents to example. One item to keep in mind is any ports you read and write from for the driver are defined in the base
  system architecture in defines.h . This is handled by the compiler in the linking stage.

  \paragraph{Makefile} should require no changes from driver to driver. It will locate all files in the src folder that are C source files. All header files are expected to be
  in the root of the folder along side the makefile. The names of all libraries are expected to be lower case and the same as the folder name for the src and header files using similar naming.

  \paragraph{Header} will contain all public functions that can be called by the application. All of the doxygen comments are also located in this file. Any doxygen specific settings are in
  the config file dox.cfg.

  \newpage

  \section{Architecture}

  \par
  This will be an in depth look at how the makefile, engines, utilities, drivers, and architecture are all put together. Along with being a general roadmap. Since this is
  pre-alpha, well its simply a TODO.

  \newpage

  \section{Driver Documentation}

  \subsection{TMS99XX Doxygen}
  \par
  If viewing the PDF version, please see tms99XX.pdf
  If viewing in html follow the link,
  \href{https://sparkletron.github.io/RODAC/manual/dox/tms99XX/html/index.html}{TMS99XX HTML Doxygen},
  for the HTML version of the document.

  \subsection{SN76489 Doxygen}
  \par
   If viewing the PDF version, please see sn76489.pdf
   If viewing in html follow the link,
  \href{https://sparkletron.github.io/RODAC/manual/dox/sn76489/html/index.html}{SN76489 HTML Doxygen},
  for the HTML version of the document.

  \subsection{GISND Doxygen}
  \par
   If viewing the PDF version, please see gisnd.pdf
   If viewing in html follow the link,
  \href{https://sparkletron.github.io/RODAC/manual/dox/gisnd/html/index.html}{GISND HTML Doxygen},
  for the HTML version of the document.

\end{document}
